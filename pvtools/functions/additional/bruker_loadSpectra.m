function [spectra, abscissaValuesHz, abscissaValuesPpm] = bruker_loadSpectra(procno, LB, zeroFillFactor, compensateGroupDelay)
% bruker_loadSpectra Load spectra from pre-processed time-domain data.
%
% [spectra, abscissaValuesHz, abscissaValuesPpm] = ...
%     bruker_loadSpectra(procno, [LB], [zeroFillFactor], [compensateGroupDelay]);
%
% This function loads preprocessed time-domain data (fid_proc files), 
% generated by the reconstructions of some Bruker spectroscopic methods and 
% spectroscopic imaging methods. The preprocessed time-domain data is then
% Fourier transformed, resulting in a complex spectrum for each voxel in
% the dataset.
%
% Input:
%   procno                procno path of a reconstructed spectroscopic 
%                         dataset or spectroscopic imaging dataset
%
% Optional input:
%   LB                    parameter for additional line broadening, using 
%                         exponential damping of the time domain data. 
%                         Note that the reconstructed data can already 
%                         contain a non-zero LB, depending on the 
%                         reconstruction parameters RECO_wdw_mode and 
%                         RECO_lb. Default is 0 (off), its unit is Hz.
%   zeroFillFactor        zero-filling factor. The number of acquired 
%                         spectral points is multiplied with this factor 
%                         to obtain the size of the resulting spectrum. 
%                         The default is 1 (no zero-filling)
%   compensateGroupDelay  compensate any remaining group delay from the 
%                         digital filter process. Default is true.
%
% Output:
%   spectra               array of complex spectra (nPoints spectral points)
%                         Dimension: (nPoints, dim1, dim2, dim3, nRepetitions),
%                         with spatial dimensions dim1, dim2, and dim3.
%                         For pure spectroscopic methods, the spatial 
%                         dimensions are all equal to 1.
%
%   abscissaValuesHz      the corresponding abscissa value for each spectral 
%                         point, in Hz. The abscissa values in the array 
%                         are in descending order.
%
%   abscissaValuesPpm     the corresponding abscissa value for each spectral
%                         point, in ppm. The abscissa values in the array 
%                         are in descending order.
%
% Note:
%   To display the spectra in spectroscopic convention (descending abscissa
%   values), either plot a spectrum directly
%
%     plot(real(spectra(:,1,1,1,1)));
%
%   When plotting with labels on the frequency axis, the x-axis must be
%   reversed. For example:
%     
%     plot(abscissaValuesPpm, real(spectra(:,1,1,1,1)));
%     set(gca, 'xdir','reverse');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Copyright (c) 2021 - 2022
% Bruker BioSpin MRI GmbH
% D-76275 Ettlingen, Germany
%
% All Rights Reserved
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Set defaults for optional parameters, if no value is given.
if ~exist('LB','var')
    LB = 0;
end

if ~exist('zeroFillFactor','var')
    zeroFillFactor = 1;
end

if ~exist('compensateGroupDelay','var')
    compensateGroupDelay = true;
end

% Import required parameters.
Reco = readBrukerParamFile([procno filesep 'reco']);

% Import pre-processed time-domain data.
rawObj = RawDataObject(procno, 'fid_proc');

% Determine group delay
if (isfield(rawObj.Acqp,'ACQ_RxFilterInfo'))
    groupDelay = rawObj.Acqp.ACQ_RxFilterInfo(1,1);
elseif (isfield(rawObj.Acqp,'GRPDLY'))
    groupDelay = rawObj.Acqp.GRPDLY;
else
    if (compensateGroupDelay) 
       warning('MATLAB:bruker_warning', 'No group delay found.'); 
    end
    groupDelay = 0;
end

isEPSI = ~isempty(strfind(rawObj.Acqp.ACQ_method,'EPSI'));

nRepetitions = Reco.RecoNumRepetitions;
spatialDims = length(Reco.RECO_size)-1;
spatialSizes = ones(1,3);

if isEPSI
    % In EPSI, the spectral dimension is in between the first two spatial
    % dimensions
    spatialSizes(1) = Reco.RECO_size(1);
    nPoints = Reco.RECO_size(2);
    spatialSizes(2) = Reco.RECO_size(3);
    if 3 == spatialDims
        spatialSizes(3) = Reco.RECO_size(4);
    end
    SWH = rawObj.Method.SpecBand;
    SWppm = rawObj.Method.SpecBandPpm;
else
    nPoints = Reco.RECO_size(1);
    for dim = 1:spatialDims
        spatialSizes(dim) = Reco.RECO_size(dim+1);
    end
    SWH = rawObj.Method.PVM_SpecSWH(1);
    SWppm = rawObj.Method.PVM_SpecSW(1);
end

if 2 == spatialDims
    spatialSizes(3) = Reco.RecoObjectsPerRepetition;
end

nVoxels = prod(spatialSizes)*nRepetitions;

timeDomain = rawObj.data{1};
if numel(timeDomain) ~= nPoints * nVoxels
    error('Error: reco and fid_proc files are inconsistent.');
end

if isEPSI
    % sort spectral dimension to the front
    timeDomain = reshape(timeDomain,[spatialSizes(1) nPoints spatialSizes(2) spatialSizes(3) nRepetitions]);
    timeDomain = permute(timeDomain,[2,1,3,4,5]);
    timeDomain = reshape(timeDomain,[1 nPoints nVoxels]);
end

% Perform zero-filling
if (zeroFillFactor > 1)
    newNpoints = round(nPoints * zeroFillFactor);
    timeDomainZeroFill = zeros([1 newNpoints nVoxels]);
    timeDomainZeroFill(:,1:nPoints,:) = timeDomain;
    timeDomain = timeDomainZeroFill;
    nPoints = newNpoints;
elseif (zeroFillFactor > 0)
    newNpoints = round(nPoints * zeroFillFactor);
    timeDomain = timeDomain(:,1:newNpoints,:);
    nPoints = newNpoints;
end

tAxis = 0:(nPoints-1);

% Perform line broadening
% A prefactor pi/2 is used in topspin because multiplication is on re/im 
% parts interleaved. Here, re and im are scaled together, and so nPoints
% is only half w.r.t. topspin. In other words, the factor 1/2 is inside 
% nPoints.
if LB ~= 0
    em = exp(-pi * LB/SWH * tAxis);
    timeDomain = timeDomain.*repmat(em,[1,1,nVoxels]);
end

% Perform Fourier-transformation on first direcion, with 0 Hz in the
% center.
ftshift=exp(1i*pi*tAxis); % 1 -1 1 -1 ...
spectra = timeDomain .* repmat(ftshift, [1, 1, nVoxels]);
spectra = ifft(spectra); % exponent=+1
spectra = reshape(spectra, [nPoints spatialSizes nRepetitions]);

% For ParaVision 360 version before V3.0, and only for single-channel 
% acquisitions: Perform checkerboard phase-correction that is done in PV
% reconstruction only *after* fid_proc is written.
if bruker_getAcqPvVersion(rawObj.Acqp, 'is360') ...
        && bruker_getAcqPvVersion(rawObj.Acqp, 'major') < 3 ...
        && bruker_getSelectedReceivers(rawObj.Acqp, 0) == 1

    checkerboard = ones(spatialSizes);
    for dim=1:spatialDims
        line = ones(spatialSizes(dim), 1);
        line(2:2:end) = -1;
        location = spatialSizes;
        location(dim) = 1;
        checkerboard = checkerboard .* repmat(shiftdim(line, 1-dim), location);
    end
    spectra = spectra .* repmat(shiftdim(checkerboard, -1), [nPoints 1 1 1 nRepetitions]);
end

% Perform group delay compensation
if compensateGroupDelay
    dphi = groupDelay/nPoints*2*pi;
    phaseRamp = exp(-1i*(dphi*tAxis)).';
    spectra = spectra .* repmat(phaseRamp, [1, spatialSizes, nRepetitions]);
end

% Transpose first two spatial dimensions, if necessary.
if any(Reco.RECO_transposition > 0)
    if sum(Reco.RECO_transposition > 0) == length(Reco.RECO_transposition)
        % entries indicate transposition for all slices
        spectra = permute(spectra, [1 3 2 4 5]);
    else
        % some slices need to be transposed, others not. The result of this
        % operation cannot be stored in a common matrix, because matrix 
        % sizes can be different per slice.
        warning('Transposition could not be applied.');
    end
end

% Calculate abscissa values
ppmAtBaseFreq = rawObj.Method.PVM_FrqWorkPpm(1); % workingChemicalShift
f = transpose((nPoints/2):-1:(-nPoints/2+1)); % column vector, like the spectra

abscissaValuesHz = SWH * f / nPoints;
abscissaValuesPpm = SWppm * f / nPoints + ppmAtBaseFreq;

