function specGrid(spectra, bkgdImg, opts)
arguments
    spectra (:,:,:) double
    bkgdImg (:,:) double
    opts.mode {mustBeMember(opts.mode, {'real', 'imag', 'abs'})} = 'real'
    opts.gapX double = 0.02 % horizontal gap (as fraction of tile)
    opts.gapY double = 0.02 % vertical gap (as fraction of tile)
    opts.border logical = false
    opts.borderColor = 'w'
end

[nPoints, dimX, dimY] = size(spectra);

% Flip image vertically to match bottom-to-top layout
%bkgdImg = flipud(bkgdImg);
[imgH, imgW] = size(bkgdImg);

% Create figure and single axes
fig = figure('Units', 'normalized', 'Position', [0.2, 0.2, 0.6, 0.6]);
ax = axes(fig);
imagesc(bkgdImg', 'Parent', ax);
axis(ax, 'image');
axis(ax, 'off');
hold(ax, 'on');
colormap(ax, 'gray');

% Tile sizes in image coordinates
tileW = imgW / dimX;
tileH = imgH / dimY;

% Optional: normalize all spectra for consistent scaling
globalMin = inf;
globalMax = -inf;

for x = 1:dimX
    for y = 1:dimY
        spec = spectra(:, x, y);
        switch opts.mode
            case 'real', ydata = real(spec);
            case 'imag', ydata = imag(spec);
            case 'abs',  ydata = abs(spec);
        end
        globalMin = min(globalMin, min(ydata));
        globalMax = max(globalMax, max(ydata));
    end
end

% Scale factor to fit spectrum vertically into tile
yRange = globalMax - globalMin;
if yRange == 0, yRange = 1; end  % prevent division by zero

% Plot each spectrum
for x = 1:dimX
    for y = 1:dimY
        % Get tile position in image coordinates
        left   = (x - 1) * tileW;
        bottom = (dimY - y) * tileH;

        % Apply padding
        padX = opts.gapX * tileW;
        padY = opts.gapY * tileH;

        x0 = left   + padX;
        x1 = left   + tileW - padX;
        y0 = bottom + padY;
        y1 = bottom + tileH - padY;

        % Spectrum data
        spec = spectra(:, x, y);
        switch opts.mode
            case 'real', ydata = real(spec);
            case 'imag', ydata = imag(spec);
            case 'abs',  ydata = abs(spec);
        end

        % Normalize spectrum to [0, 1]
        yScaled = (ydata - globalMin) / yRange;

        % Map to image coordinates
        xVals = linspace(x0, x1, nPoints);
        yVals = y0 + yScaled * (y1 - y0);

        % Plot spectrum
        plot(ax, xVals, yVals, 'k', 'LineWidth', 1);

        % Optional border
        if opts.border
            rectangle('Position', [left, bottom, tileW, tileH], ...
                      'EdgeColor', opts.borderColor, ...
                      'LineWidth', 1, ...
                      'Parent', ax);
        end
    end
end

hold(ax, 'off');
end
